# 《汇编语言》—— 第二版

mov、add、sub 指令

    mov 寄存器,数据         mov ax,8
    mov 寄存器,寄存器       mov ax,bx
    mov 寄存器,内存单元     mov ax,[0] 
    mov 内存单元,寄存器     mov [0],ax
    mov 段寄存器,寄存器     mov ds,ax
    mov 寄存器,段寄存器     mov ax,ds
    mov 内存单元,段寄存器    mov [0],cs
    mov 段寄存器,内存单元    mov ds,[0]

### 一、基本知识

内存划分成多个存储单元进行存储，一条街相当于内存，街上每个店面的门牌号相当于存储单元。存储单元从0开始编号，一个存储单元可以存储一个Byte，即8个二进制位。

总线就是一根根导线的集合，从逻辑上分为3类

1. 地址总线

    一根导线可以传送的稳定状态只有两种，高电平或低电平，用二进制表示就是1或0，就是一个二进制位。

    一个CPU有N根地址线，CPU的地址总线宽度为N，CPU最多可以寻找2的N次方个内存单元。

2. 控制总线

    控制总线是一些不同控制线的集合。控制总线的宽度决定了CPU对外部器件的控制能力。

    “读信号输出”的控制线负责由CPU向外传送读信号；“写信号输出”的控制线负责传送写信号。


3. 数据总线

    数据总线的宽度决定了CPU和外界的数据传送速度。8根数据总线一次可传送一个8位二进制数据（即一个字节）。

通过机器码驱动CPU进行工作，CPU根据机器码的指令通过总线与其他器件（芯片）进行交互，地址线用于寻找存储单元的地址，控制线发送内存读写命令（选中存储器芯片，通知它将要读写数据），数据线传送存储单元中的数据。


内存地址空间：
    
    由多个物理存储器件所组成的逻辑存储器就是内存地址空间。

    每个物理设备在逻辑存储器中都占有一个地址段，即一段地址空间。CPU在这段地址空间中读写数据，实际上就是在相对应的物理存储器中读写数据。


- - -

### 二、寄存器

8086CPU 共有 14 个寄存器

- AX、BX、CX、DX 为通用寄存器

    1. 每个寄存器大小为 16 位，即 2 个字节
    2. 每个寄存器可以分成两个可独立使用的 8 位寄存器
    3. AX 分为 AL 和 AH，AL 进行运算如果进位不会保存在 AH 中

    ![2-4.jpg](/images/assembly/2-4.jpg "图2-4")

- CS、DS、SS、ES 为段寄存器

    不能将数据直接送入段寄存器，这属于8086CPU硬件设计问题

    - CS: 代码（指令）段寄存器
    - DS: 数据段寄存器


- IP 

    指令指针寄存器（指令偏移地址）

8086CPU 可以一次性处理一下两种尺寸的数据

- 字节：byte，由8个bit组成，可以存在8位寄存器中
- 字：word，由两个字节组成，这两个字节分别称为这个字的高位字节和地位字节

#### 注意：在进行数据传送或运算时，指令的两个操作对象的位数应当是一致的

正确的指令：

    mov ax,bx
    mov bx,cx
    mov ax,18H
    mov al,18H
    add ax,bx
    add ax,20000

错误的指令：

    mov ax,bl   (在8位寄存器和16位寄存器之间传送数据)
    mov bh,ax   (在16位寄存器和8位寄存器之间传送数据)
    mov al,20000    (8位寄存器最大可存放值为255的数据)
    add al,100H     (将一个高于8位的数据加到一个8位寄存器中)


典型的CPU由运算器、控制器、寄存器等器件构成，这些器件靠内部总线相连。

- 运算器进行信息处理
- 寄存器进行信息存储
- 控制器控制各种器件进行工作
- 内部总线连接各种器件，进行数据传送

物理地址：存储单元在内存地址空间中的唯一地址。CPU向地址总线发送的必须是物理地址，所以必须要在CPU内部先形成这个物理地址，每种CPU形成的方式都不同。

CPU的位数：例如8086CPU，16位结构（16位机、字长为16位）

1. 运算器一次最多处理16位数据；
2. 寄存器的最大宽度为16位；
3. 寄存器和运算器之间的通路为16位

![2-6.jpg](/images/assembly/2-6.jpg "图2-6")

当8086CPU读写内存时：

1. CPU中的相关部件提供两个16位的地址，一个称为段地址，另一个称为偏移地址
2. 段地址和偏移地址通过内部总线送入一个称为地址加法器的部件；
3. 地址加法器将两个16位地址合成为一个20位的物理地址，达到1MB的寻址能力；
4. 地址加法器通过内部总线将20位物理地址送入输入输出控制电路；
5. 输入输出控制电路将20位物理地址送上地址总线
6. 20位物理地址被地址总线传送到存储器

地址加法器采用 

    物理地址 = 段地址 × 16 + 偏移地址
    段地址 × 16：相当于段地址二进制表示左移4位（十六进制左移1位）

    一个数据的二进制形式左移1位，相当于×2
    一个数据的十进制形式左移1位，相当于×10
    一个数据的十六进制形式左移1位，相当于×16

8086CPU的寻址功能是：

    基础地址 + 偏移地址 = 物理地址
    段地址 × 16 只是基础地址的一种具体实现


将若干地址连续的内存单元看作一个段，段的长度受偏移地址的影响，偏移地址为16位，寻址能力为64KB，所以一个段的最大长度为64KB。段地址由CPU划分，内存并没有分段。

CPU可以用不同的段地址和偏移地址形成同一个物理地址

    段地址    偏移地址    物理地址
    2000H    1F60H      21F60H
    2100H    0F60H      
    21F0H    0060H
    21F6H    0000H
    1F00H    2F60H

段寄存器：提供内存单元的段地址

    段寄存器和IP寄存器（指令指针寄存器）配合工作，可以得到要读取指令的地址（IP就相当于偏移地址），读取的指令进入指令缓冲器，IP中的值自动增加（读取的指令占几个内存单元就加几），以使CPU可以读取下一条指令，然后由执行控制器执行指令。

修改 CS:IP 中的值，jmp 段地址:偏移地址

    jmp 2AE3:3  -> CS=2AE3H, IP=0003H,CPU将从 2AE33 处读取指令
    jmp 3:0B16  -> CS=0003H, IP=0B16H,CPU将从 00B46 处读取指令

    仅修改IP的值

    jmp ax  
    执行前: ax=1000H, CS=2000H, IP=0003H
    执行后: ax=1000H, CS=2000H, IP=1000H

    jmp bx
    执行前: bx=0B16H, CS=2000H, IP=0003H
    执行后: bx=0B16H, CS=2000H, IP=0B16H

代码段

    我们可以将长度为N(N≤64KB)的一组代码，存在一组地址连续、起始地址为16的倍数的内存单元中。这段用来存放代码的内存就是定义了一个代码段。

    mov ax,0000     (B8 00 00)
    add ax,0123     (05 23 01)
    mov bx,ax       (8B D8)
    jmp bx          (FF E3)
    这段长度为10个字节的指令，存放在123B0H~123B9H的一组内存单元中，这段内存就是一个代码段。

如果要让CPU执行我们放在代码段中的指令，必须要将CS:IP指向所定义的代码段中的第一条指令的首地址。

- - -

### 三、寄存器（内存访问）

内存中字的存储

    CPU中，用16位寄存器来存储一个字。高8位存放高位字节，低8位存放地位字节。在内存中存储时，由于内存单元是字节单元（一个单元存放一个字节），所以需要两个连续的内存单元来存放一个字，第八位存储在低地址单元中，高八位存储在高地址单元中。

段地址寄存器

    DS是数据段寄存器，保存的是内存单元的段地址，与[]一起配合使用（偏移地址），得到内存单元的物理地址。

栈寄存器

    SS(段地址):SP(偏移地址) 指向栈顶位置，如果栈中没有元素，栈顶默认指向最后一个字内存单元地址 + 2的位置。

    例如：10000H~1000FH内存空间表示栈范围，最后一个字内存单元地址为1000EH（一个字占两个内存单元），则栈顶的地址为10010H。

    在使用时注意栈的范围，如果超出范围可能会覆盖原有的内存单元或获取错误的内存单元。

    不能直接向SS寄存器里面写入数据，需要用其他寄存器中转

- - -

### 四、第一个程序

汇编语言由源代码编译成可执行文件需要进行编译和连接两个步骤

源程序包含两种指令：

1. 伪指令

    没有对应的机器指令，由编译器来执行
    ```
    定义一个代码段
    段名 segment
    ...
    ...
    段名 ends
    ```
    ```
    end 是一个汇编程序的结束标记
    ```
    ```
    assume 
    假设某一段寄存器和程序中的某一个用segment...ends定义的段相关联
    ```

2. 汇编指令

    有对应的机器码的指令，最终为CPU所执行

3. 标号

    一个标号指代了一个地址

4. 程序返回

    ```
    mov ax,4c00H
    int 21H
    ```
|目的|相关指令|指令性质|指令执行者|
|:-:|:-:|:-:|:-:|
|通知编译器一个段开始|段名 segment|伪指令|编译时，有编译器执行|
|通知编译器一个段结束|段名 ends|伪指令|编译时，由编译器执行|
|通知编译器程序结束|end|伪指令|编译时，由编译器执行|
|程序返回|mov ax,4c00H int 21H|汇编指令|执行时，由CPU执行|

编译：把源文件中的汇编指令编译成机器码，得到目标文件XXX.obj

连接：

1. 当源程序很大时，可以将它分为多个源程序文件来编译，每个源程序编译成目标文件后，再用连接程序将它们连接到一起，生成一个可执行文件；
2. 程序中调用了某个库文件中的子程序，需要将这个库文件和该程序生成的目标文件连接到一起，生成一个可执行文件；
3. 一个源程序编译后，得到了存有机器码的目标文件，目标文件中的有些内容还不能直接用来生成可执行文件，连接程序将这些内容处理为最终可执行信息。所以，在只有一个源程序文件，而又不需要调用某个库中的子程序的情况下，也必须用连接程序对目标文件进行处理，生成可执行文件。


自己写的程序一般是由shell（壳）来加载进内存并设置CS:IP指向程序的入口，然后由CPU运行程序。


- - -

### 五、[BX]和loop指令

[bx]同[0]一样，也表示一个内存单元，它的偏移地址在bx中

    mov ax,[bx]
    表示将一个内存单元的内容送入ax，这个内存单元的长度为2字节（字单元），存放一个字，偏移地址在bx中，段地址在ds中。

loop 指令

    loop 标号
    ①(cx)=(cx)-1
    ②判断cx中的值，不为零则转至标号处执行程序，如果为零则向下执行

段前缀

在访问内存单元的指令中显示的指定内存单元段地址所在的段寄存器，称为段前缀。

    mov ax,ds:[bx]
    mov ax,cs:[bx]
    mov ax,ss:[bx]
    mov ax,es:[bx]
    mov ax,ss:[0]
    mov ax,cs:[0]
    "ds:" "cs:" 等在汇编语言中称为段前缀
